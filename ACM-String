/*************  SAM (后缀自动机)   ***************/
parent tree上DP得到每一个类中的子串和在原串中出现的位置相关的一些信息。例如，出现的次数，第一次出现的位置，出现在某个位置之后的次数等。
洛谷p3975 //求字典序第K小串 
struct SAM{//求字典序第K小串 
	int l[maxn<<1],fa[maxn<<1],nxt[maxn<<1][26];
	int last,cnt,c[maxn<<1],siz[maxn<<1],sum[maxn<<1],a[maxn<<1];
	void Init()
	{
		memset(siz,0,sizeof(siz));
		memset(c,0,sizeof(c));
		memset(sum,0,sizeof(sum));
		memset(a,0,sizeof(a));
		last=cnt=1;
		memset(nxt[1],0,sizeof(nxt[1]));
		fa[1]=l[1]=0;
	}
	int NewNode()
	{
		cnt++;
		memset(nxt[cnt],0,sizeof(nxt[cnt]));
		fa[cnt]=l[cnt]=0;
		return cnt;
	}
	void Add(int ch)
	{
		int p=last,np=NewNode();
		last=np; l[np]=l[p]+1;
		siz[np]=1;
		while(p&&!nxt[p][ch]) nxt[p][ch]=np,p=fa[p];
		if(!p) fa[np]=1;
		else
		{
			int q=nxt[p][ch];
			if(l[q]==l[p]+1) fa[np]=q;
			else
			{
				int nq=NewNode();
				memcpy(nxt[nq],nxt[q],sizeof(nxt[q]));
				fa[nq]=fa[q];
				l[nq]=l[p]+1;
				fa[np]=fa[q]=nq;
				while(nxt[p][ch]==q) nxt[p][ch]=nq,p=fa[p];
			}
		}
	}
	void Build()
	{
        int len=strlen(s+1);
        for(int i=1;i<=len;i++) Add(s[i]-'a');
	}
	void topusort()
	{
		for(int i=1;i<=cnt;++i) c[l[i]]++;
		for(int i=1;i<=cnt;++i) c[i]+=c[i-1];
		for(int i=1;i<=cnt;++i) a[c[l[i]]--]=i;
		for(int i=cnt;i;--i)
		{//t==1:不同位置的相同子串视为不同 
			if(t) siz[fa[a[i]]]+=siz[a[i]];
			else siz[a[i]]=1;//t==0:视为相同 
		}
		siz[1]=0;
		for(int i=cnt;i;--i)
		{
			sum[a[i]]=siz[a[i]];
			for(int j=0;j<26;++j)
				if(nxt[a[i]][j]) sum[a[i]]+=sum[nxt[a[i]][j]];
		}
	}	
	void dfs()
	{
		if(k>sum[1]){puts("-1");return ;}
		int now=1;
		while(k>0)
		{
			int p=0;
			while(k>sum[nxt[now][p]])
			{
				k-=sum[nxt[now][p]];
				p++;
			}
			now=nxt[now][p];
			putchar('a'+p);
			k-=siz[now];
		}
		return ;
	}
} sam;
int main()
{
	scanf("%s%d%d",s+1,&t,&k);
	sam.Init();   
	sam.Build(); 
	sam.topusort();  
	sam.dfs();
	return 0;
}


edit by songhailei
